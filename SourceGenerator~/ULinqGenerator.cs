using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ULinq.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class ULinqGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var inlineDecls = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "ULinq.InlineAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => (MethodDeclarationSyntax)ctx.TargetNode)
            .Collect();

        var classes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is ClassDeclarationSyntax,
            transform: static (ctx, _) => ctx);

        var combined = classes.Combine(inlineDecls);

        context.RegisterSourceOutput(combined, static (spc, pair) =>
        {
            var (ctx, inlineSyntaxNodes) = pair;
            var result = ExtractClassSource(spc, ctx, inlineSyntaxNodes);
            if (result is null) return;
            var (hintName, diskName, code, diagnostics) = result.Value;
            spc.AddSource($"{hintName}.udon.g.cs", SourceText.From(code, Encoding.UTF8));
            foreach (var d in diagnostics)
                spc.ReportDiagnostic(d);
            try
            {
                WriteToDisk(diskName, code, ctx.Node.SyntaxTree.FilePath);
            }
            catch (System.Exception ex)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.UL0003, ctx.Node.GetLocation(), ex.Message));
            }
        });
    }

    static (string hintName, string diskName, string code, ImmutableArray<Diagnostic> diagnostics)? ExtractClassSource(
        SourceProductionContext spc, GeneratorSyntaxContext ctx, ImmutableArray<MethodDeclarationSyntax> inlineSyntaxNodes)
    {
        try
        {
            return ExtractClassSourceCore(ctx, inlineSyntaxNodes);
        }
        catch (System.Exception ex)
        {
            var className = (ctx.Node as ClassDeclarationSyntax)?.Identifier.Text ?? "?";
            spc.ReportDiagnostic(Diagnostic.Create(
                Diagnostics.UL0004, ctx.Node.GetLocation(), className, ex.Message));
            return null;
        }
    }

    static (string hintName, string diskName, string code, ImmutableArray<Diagnostic> diagnostics)? ExtractClassSourceCore(
        GeneratorSyntaxContext ctx, ImmutableArray<MethodDeclarationSyntax> inlineSyntaxNodes)
    {
        if (ctx.Node is not ClassDeclarationSyntax classDecl) return null;
        if (!classDecl.DescendantNodes().OfType<InvocationExpressionSyntax>().Any()) return null;
        var semanticModel = ctx.SemanticModel;

        var symbol = semanticModel.GetDeclaredSymbol(classDecl);
        if (symbol is not INamedTypeSymbol namedType) return null;

        if (inlineSyntaxNodes.IsDefaultOrEmpty) return null;

        var inlineMethods = ResolveInlineMethods(semanticModel.Compilation, inlineSyntaxNodes);
        if (inlineMethods.Count == 0) return null;

        var rewriter = new ULinqRewriter(semanticModel, inlineMethods);
        var transformed = (ClassDeclarationSyntax)rewriter.Visit(classDecl);

        if (!rewriter.HasTransformed) return null;

        if (rewriter.GeneratedMethods.Count > 0)
            transformed = transformed.AddMembers(rewriter.GeneratedMethods.ToArray());

        var root = classDecl.SyntaxTree.GetRoot();
        var usings = root.DescendantNodes()
            .OfType<UsingDirectiveSyntax>()
            .Where(u => u.Name?.ToString() != "ULinq")
            .Select(u => u.ToFullString().Trim());

        var ns = namedType.ContainingNamespace;
        var hasNamespace = ns is { IsGlobalNamespace: false };

        var sb = new StringBuilder();
        sb.AppendLine($"// @source: {classDecl.SyntaxTree.FilePath}");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// ULinq Source Generator");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#if ULINQ_GENERATED");
        sb.AppendLine();

        foreach (var u in usings)
            sb.AppendLine(u);
        sb.AppendLine();

        if (hasNamespace)
        {
            sb.AppendLine($"namespace {ns.ToDisplayString()}");
            sb.AppendLine("{");
            sb.AppendLine(transformed.NormalizeWhitespace().ToFullString());
            sb.AppendLine("}");
        }
        else
        {
            sb.AppendLine(transformed.NormalizeWhitespace().ToFullString());
        }

        sb.AppendLine("#endif");

        var hintName = namedType.ToDisplayString().Replace('.', '_');
        var diskName = Path.GetFileNameWithoutExtension(classDecl.SyntaxTree.FilePath);
        if (string.IsNullOrEmpty(diskName))
            diskName = namedType.Name;
        return (hintName, diskName, sb.ToString(), rewriter.CollectedDiagnostics);
    }

    static string ResolveTempDir(string syntaxTreeFilePath)
    {
        if (!string.IsNullOrEmpty(syntaxTreeFilePath))
        {
            var normalized = syntaxTreeFilePath.Replace('\\', '/');
            var idx = normalized.IndexOf("/Assets/", System.StringComparison.OrdinalIgnoreCase);
            if (idx > 0)
                return Path.Combine(normalized.Substring(0, idx), "Temp", "ULinqGenerated");
        }
        return Path.Combine("Temp", "ULinqGenerated");
    }

    static void WriteToDisk(string name, string code, string syntaxTreeFilePath)
    {
        var dir = ResolveTempDir(syntaxTreeFilePath);
        Directory.CreateDirectory(dir);
        File.WriteAllText(Path.Combine(dir, $"{name}.udon.g.cs"), code);
    }

    static List<InlineMethodInfo> ResolveInlineMethods(
        Compilation compilation, ImmutableArray<MethodDeclarationSyntax> decls)
    {
        var result = new List<InlineMethodInfo>();
        foreach (var decl in decls)
        {
            var model = compilation.GetSemanticModel(decl.SyntaxTree);
            if (model.GetDeclaredSymbol(decl) is IMethodSymbol methodSymbol)
                result.Add(new InlineMethodInfo(methodSymbol, decl));
        }
        return result;
    }
}
