using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace UdonLambda.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class UdonLambdaGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var inlineDecls = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "UdonLambda.InlineAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => (MethodDeclarationSyntax)ctx.TargetNode)
            .Collect();

        var classes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is ClassDeclarationSyntax,
            transform: static (ctx, _) => ctx);

        var combined = classes.Combine(inlineDecls);

        context.RegisterSourceOutput(combined, static (spc, pair) =>
        {
            var (ctx, inlineSyntaxNodes) = pair;
            var result = ExtractClassSource(ctx, inlineSyntaxNodes);
            if (result is null) return;
            var (hintName, diskName, code, diagnostics) = result.Value;
            spc.AddSource($"{hintName}.udon.g.cs", SourceText.From(code, Encoding.UTF8));
            WriteToDisk(diskName, code);
            foreach (var d in diagnostics)
                spc.ReportDiagnostic(d);
        });
    }

    static (string hintName, string diskName, string code, ImmutableArray<Diagnostic> diagnostics)? ExtractClassSource(
        GeneratorSyntaxContext ctx, ImmutableArray<MethodDeclarationSyntax> inlineSyntaxNodes)
    {
        try
        {
            return ExtractClassSourceCore(ctx, inlineSyntaxNodes);
        }
        catch (System.Exception ex)
        {
            try
            {
                var className = (ctx.Node as ClassDeclarationSyntax)?.Identifier.Text ?? "?";
                var dir = Path.Combine("Temp", "UdonLambdaGenerated");
                Directory.CreateDirectory(dir);
                File.AppendAllText(Path.Combine(dir, "__errors.log"),
                    $"[{className}] {ex.GetType().Name}: {ex.Message}\n{ex.StackTrace}\n\n");
            }
            catch { }
            return null;
        }
    }

    static (string hintName, string diskName, string code, ImmutableArray<Diagnostic> diagnostics)? ExtractClassSourceCore(
        GeneratorSyntaxContext ctx, ImmutableArray<MethodDeclarationSyntax> inlineSyntaxNodes)
    {
        if (ctx.Node is not ClassDeclarationSyntax classDecl) return null;
        if (!classDecl.DescendantNodes().OfType<InvocationExpressionSyntax>().Any()) return null;
        var semanticModel = ctx.SemanticModel;

        var symbol = semanticModel.GetDeclaredSymbol(classDecl);
        if (symbol is not INamedTypeSymbol namedType) return null;

        if (inlineSyntaxNodes.IsDefaultOrEmpty) return null;

        var inlineMethods = ResolveInlineMethods(semanticModel.Compilation, inlineSyntaxNodes);
        if (inlineMethods.Count == 0) return null;

        var rewriter = new UdonLambdaRewriter(semanticModel, inlineMethods);
        var transformed = (ClassDeclarationSyntax)rewriter.Visit(classDecl);

        if (!rewriter.HasTransformed) return null;

        if (rewriter.GeneratedMethods.Count > 0)
            transformed = transformed.AddMembers(rewriter.GeneratedMethods.ToArray());

        var root = classDecl.SyntaxTree.GetRoot();
        var usings = root.DescendantNodes()
            .OfType<UsingDirectiveSyntax>()
            .Where(u => u.Name?.ToString() != "UdonLambda" && u.Name?.ToString() != "ULinq")
            .Select(u => u.ToFullString().Trim());

        var ns = namedType.ContainingNamespace;
        var hasNamespace = ns is { IsGlobalNamespace: false };

        var sb = new StringBuilder();
        sb.AppendLine($"// @source: {classDecl.SyntaxTree.FilePath}");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// UdonLambda Source Generator");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#if UDONLAMBDA_GENERATED");
        sb.AppendLine();

        foreach (var u in usings)
            sb.AppendLine(u);
        sb.AppendLine();

        if (hasNamespace)
        {
            sb.AppendLine($"namespace {ns.ToDisplayString()}");
            sb.AppendLine("{");
            sb.AppendLine(transformed.NormalizeWhitespace().ToFullString());
            sb.AppendLine("}");
        }
        else
        {
            sb.AppendLine(transformed.NormalizeWhitespace().ToFullString());
        }

        sb.AppendLine("#endif");

        var hintName = namedType.ToDisplayString().Replace('.', '_');
        var diskName = Path.GetFileNameWithoutExtension(classDecl.SyntaxTree.FilePath);
        if (string.IsNullOrEmpty(diskName))
            diskName = namedType.Name;
        return (hintName, diskName, sb.ToString(), rewriter.CollectedDiagnostics);
    }

    static void WriteToDisk(string name, string code)
    {
        try
        {
            var dir = Path.Combine("Temp", "UdonLambdaGenerated");
            Directory.CreateDirectory(dir);
            File.WriteAllText(Path.Combine(dir, $"{name}.udon.g.cs"), code);
        }
        catch { }
    }

    static List<InlineMethodInfo> ResolveInlineMethods(
        Compilation compilation, ImmutableArray<MethodDeclarationSyntax> decls)
    {
        var result = new List<InlineMethodInfo>();
        foreach (var decl in decls)
        {
            var model = compilation.GetSemanticModel(decl.SyntaxTree);
            if (model.GetDeclaredSymbol(decl) is IMethodSymbol methodSymbol)
                result.Add(new InlineMethodInfo(methodSymbol, decl));
        }
        return result;
    }
}
